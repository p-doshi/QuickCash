stages:
  - build
  - lint
  - test

variables:
  JOB_FILE: jobId

before_script:
  # Make the gradle wrapper executable.
  - chmod +x ./gradlew

Build:
  image: ethrozee/android
  interruptible: true
  tags:
    - dalfcs_docker_kvm
  stage: build
  script:
    # Build the application.
    - ./gradlew :app:assembleDebug :app:assembleDebugAndroidTest

  after_script:
    # Save the job ID for the connected tests.
    - echo $CI_JOB_ID > $JOB_FILE

  artifacts:
    paths:
      # Give the results of compilation to the next stage.
      - app/build/outputs/
      - $JOB_FILE

PmdLint:
  image: ethrozee/android
  interruptible: true
  tags:
    - dalfcs_docker_kvm
  stage: lint
  needs: []
  script:
    - pmd check -d app/src -R pmdRuleset.xml -f textcolor

GradleLint:
  image: ethrozee/android
  interruptible: true
  tags:
    - dalfcs_docker_kvm
  stage: lint
  needs:
    - Build
  script:
    # Run the linter.
    - ./gradlew :app:lintDebug

  after_script:
    # Reposition lint results.
    - mv app/build/reports/lint-results-debug.html lintResults.html

  artifacts:
    when: always
    expire_in: 30 days
    paths:
      # Give the results of linting
      - lintResults.html

UnitTests:
  image: ethrozee/android
  interruptible: true
  tags:
    - dalfcs_docker_kvm
  stage: test
  needs:
    - Build
  script:
    # Run the unit tests.
    - ./gradlew :app:testDebugUnitTest

  after_script:
    # Reposition test results.
    - mv app/build/reports/tests/testDebugUnitTest testDebugUnitTest

  artifacts:
    when: always
    expire_in: 30 days
    paths:
      - testDebugUnitTest/

ConnectedTests:
  image: ethrozee/android
  interruptible: true
  tags:
    - dalfcs_docker_kvm
  stage: test
  needs:
   - Build
  variables:
    GITHUB_REPO: csci3130_group_3
    GITHUB_USER: ethroz
  script:
    # Create a unique name for a new Github action job.
    - export NAME=$CI_COMMIT_SHA

    # Login to Github.
    - cat github_token | gh auth login --with-token

    # Start a new Github action job.
    - gh workflow run android.yml -R $GITHUB_USER/$GITHUB_REPO -f commit=$NAME -f proj_id=$CI_PROJECT_ID -f job_id=$(cat $JOB_FILE)

    # Wait a bit before trying to get job ID.
    - sleep 5

    # Get the Github action job ID from the job name.
    - >
      export JOB_ID=$(
      gh run list -R $GITHUB_USER/$GITHUB_REPO --json "name,databaseId" --jq ".[] | select(.name == \"$NAME\")" |
      grep -o -P '(?<="databaseId":)\d+') &&
      echo $JOB_ID

    # Watch the Github action job.
    - gh run watch $JOB_ID -R $GITHUB_USER/$GITHUB_REPO -i 30

    # Get the logs.
    - gh run view $JOB_ID -R $GITHUB_USER/$GITHUB_REPO --log

    # Download the artifacts from the finished job.
    - gh run download $JOB_ID -R $GITHUB_USER/$GITHUB_REPO

  artifacts:
    when: always
    expire_in: 30 days
    paths:
      - testResults*/
